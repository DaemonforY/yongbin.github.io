数据仓库的重要特点之一是反应历史变化，所以如何处理维度的变化是维度设计的重要工作之一。

在Kimball的理论中，有三种缓慢变化的处理方式以及衍生出来的几种其他处理方式。阿里巴巴在处理缓慢变化维度方面，有自己独特的特点。比如对于数据量相对可控的表采用快照的方式，通过存储成本换取计算成本的降低；对于数据量巨大的表则引入极限存储的概念，在保证易用性的同时，通过计算成本换取存储成本的降低。

最后，简单介绍微型维度在避免维度快速增长方面的作用。



# 缓慢变化维

  数据仓库的重要特点之一是反应历史变化，所以如何处理维度的变化是维度设计的重要工作之一。缓慢变化维的提出是因为在现实世界中，维度的属性并不是静态的，它会随着时间的流失发生缓慢的变，这一现象称为缓慢变化的维度，简称缓慢变化维。与数据增长较为快速的事实表相比，维度变化相对缓慢。

  某些情况下，保留历史数据没有什么分析价值；某些情况下，保留历史数据将会起到至关重要的作用。在Kimball的理论中，有三种缓慢变化的处理方式，下面通过简单的实例进行说明，具体细节请翻阅Kimball的相关书籍。

  类型1：重写维度值。采用此种方式，不保留历史，始终取最新数据。比如，商品所属的类目于2015年11月16日由类目1变成类目2。采用类型1处理方式，变化前后的数据记录如下。

  表1：变化前商品表和订单表

| 商品Key | 商品ID | 商品标题 | 所属类目 | 其它属性 |
| ------- | ------ | -------- | -------- | -------- |
| 1000    | item1  | title1   | 类目1    | ...      |

| 订单Key | 日期Key    | 商品Key | 交易金额 | 其它事实 |
| ------- | ---------- | ------- | -------- | -------- |
| 9000    | 2015-11-11 | 1000    | 103.00   | ...      |

  表2：变化后商品表和订单表

| 商品Key | 商品ID | 商品标题 | 所属类目 | 其它属性 |
| ------- | ------ | -------- | -------- | -------- |
| 1000    | item1  | title1   | 类目2    | ...      |

| 订单Key | 日期Key    | 商品Key | 交易金额 | 其它事实 |
| ------- | ---------- | ------- | -------- | -------- |
| 9000    | 2015-11-11 | 1000    | 103.00   | ...      |
| 9001    | 2015-11-16 | 1000    | 89.00    | ...      |

  类型2：插入新的维度行。采用此种方式，保留历史，维度值变化前的事实和过去的维度值关联，维度值变化后的事实和当前的维度值关联。同上面的例子，采用类型2处理方式，变化前的数据同上，变化后的数据记录如下。

  表3：变化后商品表和订单表

| 商品Key | 商品ID | 商品标题 | 所属类目 | 其它属性 |
| ------- | ------ | -------- | -------- | -------- |
| 1000    | item1  | title1   | 类目1    | ...      |
| 1001    | item1  | title1   | 类目2    | ...      |

| 订单Key | 日期Key    | 商品Key | 交易金额 | 其它事实 |
| ------- | ---------- | ------- | -------- | -------- |
| 9000    | 2015-11-11 | 1000    | 103.00   | ...      |
| 9001    | 2015-11-16 | 1001    | 89.00    | ...      |

  类型3：添加维度列。类型2不能将变化前后记录的事实归一为变化前的维度或者归一为变化后的维度，比如根据业务需求，需要将11月份的交易金额全部统计到类目2上，类型2无法实现。针对此问题，采用类型3处理方式，保留历史，可以使用任何一个属性列。同上面的例子，采用类型3处理方式，变化前后的数据记录如下。通过变化后的商品表和订单表关联，可以将根据不同的业务需求，将11月份的交易金额全部统计到类目2或类目1上。

  表4：变化前商品表和订单表

| 商品Key | 商品ID | 商品标题 | 所属新类目 | 所属旧类目 | 其它属性 |
| ------- | ------ | -------- | ---------- | ---------- | -------- |
| 1000    | item1  | title1   | 类目1      | 类目1      | ...      |

| 订单Key | 日期Key    | 商品Key | 交易金额 | 其它事实 |
| ------- | ---------- | ------- | -------- | -------- |
| 9000    | 2015-11-11 | 1000    | 103.00   | ...      |

  表5：变化后商品表和订单表

| 商品Key | 商品ID | 商品标题 | 所属新类目 | 所属旧类目 | 其它属性 |
| ------- | ------ | -------- | ---------- | ---------- | -------- |
| 1000    | item1  | title1   | 类目2      | 类目1      | ...      |

| 订单Key | 日期Key    | 商品Key | 交易金额 | 其它事实 |
| ------- | ---------- | ------- | -------- | -------- |
| 9000    | 2015-11-11 | 1000    | 103.00   | ...      |
| 9001    | 2015-11-16 | 1000    | 89.00    | ...      |

  对于选择哪种方式处理缓慢变化维，根据业务的需求来选择适当的处理方式即可，并没有一个完全正确的答案。比如根据商品所属的类目统计淘宝2015年11月的成交额，商品所属的类目于2015年11月16日由类目1变成类目2，假设业务需求方不关心历史，将所有的成交额都统计到最新的类目2上，则不需要保存历史数据；假设类目1属于某个业务部门，类目2属于另一个业务部门，不同业务部门需要统计各自的业绩，则需要保留历史数据。



# 6.2 快照维表

  第一章维度的基本概念中介绍了自然键和代理键的定义，在Kimball的维度建模中，必须使用代理键作为每个维度表的主键，用于处理缓慢变化维度。比如上面的例子，商品所属的类目于2015年11月16日由类目1变成类目2。采用Kimball的类型2的处理方式如下：

| 商品Key | 商品ID | 商品标题 | 所属类目 | 其它属性 |
| ------- | ------ | -------- | -------- | -------- |
| 1000    | item1  | title1   | 类目1    | ...      |
| 1001    | item1  | title1   | 类目2    | ...      |

  但在阿里巴巴数据仓库建设的实践过程中，虽然我们使用的是Kimball的维度建模的理论，但实际并未使用代理键。我们是如何处理缓慢变化维度，如何记录变化历史的呢？为什么不使用代理键呢？

  首先看一下为什么不使用代理键。第一点原因是，由于阿里巴巴数据量庞大，使用的是阿里巴巴自主知识产权的分布式计算平台ODPS。对于分布式计算系统，不存在事务的概念，对于每个表的记录生成全局唯一的稳定的代理键难度很大，此处稳定指某条记录每次生成的代理键都相同。第二点原因是，使用代理键会大大增加ETL的复杂性，对ETL任务的开发和维护成本很高。

  下面接着讨论不使用代理键如何处理缓慢变化维度。阿里巴巴数据仓库实践中处理缓慢变化维度的方法是快照方式。数据仓库的计算周期一般是每天一次，基于此周期，处理维度变化的方式就是每天一份全量快照。比如商品维度，每天保留一份全量商品快照数据。任意一天的事实均可以取到当天的商品信息，也可以取到最新的商品信息，通过限定日期，采用自然键进行关联即可。此方法既有优势亦有弊端。

  优势主要有以下两点：

  （1）处理缓慢变化维度的方式，简单而有效，开发和维护成本低。

  （2）使用方便，理解性好。数据使用方只需要限定日期即可取到当天的快照数据。任意一天的事实快照和任意一天的维度快照通过维度的自然键进行关联即可。

  弊端主要体现在存储的极大浪费。比如某维度，每天的变化量占总体数据量比例很低，极端情况下，每天无变化，此情况下存储浪费很严重。此方法主要就是实现了牺牲存储获取ETL效率的优化和逻辑上的简化。但是一定要杜绝过度使用这种方法，而且必须要有对应的数据生命周期制度，清除无用的历史数据。

  综合来看，由于现在存储成本远低于CPU、内存等成本，此方法总体来说弊大于利。是否有方法既可以实现上面的优点，同时又可以很好地降低存储呢？答案是肯定的，那就是阿里巴巴的极限存储。

# 6.3 极限存储

  首先来看历史拉链存储。历史拉链存储是指利用维度模型中缓慢变化维TYPE2的处理方式。这种处理方式是通过新增两个时间戳字段（start_dt和end_dt），将所有以天为粒度的变更数据都记录下来，通常分区字段也是这两个时间戳字段。

  例如，1月1号，卖家A在淘宝网发布了B、C两个商品，前端商品表将生成两条记录t1、t2；1月2号，卖家A将B商品下架了，同时又发布了商品D，前端商品表将更新记录t1，又新生成记录t3；采用全量存储方式， 在1月1号这个分区中存储t1和t2两条记录；在1月2号这个分区中存储更新后的t1以及t2、t3记录。数据存储如下：

| 商品 | dt       | 卖家 | 状态 | 其他字段 |
| ---- | -------- | ---- | ---- | -------- |
| B    | 20160101 | A    | 上架 | ...      |
| C    | 20160101 | A    | 上架 | ...      |
| B    | 20160102 | A    | 下架 | ...      |
| C    | 20160102 | A    | 上架 | ...      |
| D    | 20160102 | A    | 上架 | ...      |

  如果我们采用历史拉链存储，数据存储如下，对于不变的数据，不再重复存储。

| 商品 | start_dt | end_dt   | 卖家 | 状态 | 其他字段 |
| ---- | -------- | -------- | ---- | ---- | -------- |
| B    | 20160101 | 20160102 | A    | 上架 | ...      |
| C    | 20160101 | 30001231 | A    | 上架 | ...      |
| B    | 20160102 | 30001231 | A    | 下架 | ...      |
| D    | 20160102 | 30001231 | A    | 上架 | ...      |

  这样下游应用可以通过限制 时间戳字段来获取历史数据，例如， 用户访问1月1号的数据，只需要限制： `start_dt<=20160101 and end_dt>20160101`。

  但是这种存储方式对于下游使用方的存在一定的理解障碍，特别是ODS的数据面向的下游用户包含数据分析师、前端开发等，这些人群不怎么理解维度模型的概念，因此会存在较高的解释成本。另一方面，这种存储方式用 start_dt和end_dt作分区，随着时间的推移，分区数量会极度膨胀，而现行的数据库系统都有分区数量限制。

  为了解决上述的两个问题，我们提出极限存储的方式处理：

  （1）透明化：底层的数据还是历史拉链存储，但是上层我们做一个视图操作或者在hive里做了一个hook，通过分析语句的语法树，把对极限存储前的表的查询转化成对极限存储表的查询。对于下游用户来说，极限存储表和全量存储方式是一样的：

  `Select * from A where ds =20160101 ;`

  等价于

  `Select * from A_EXST where start_dt <=20160101 and end_dt >20160101;`

  （2）分月做历史拉链：假设我们用start_dt和end_dt做分区，并且不做限制，那么可以计算下一年下来历史拉链表最多就可能产生分区数：365*364/2=66430个。如果我们在每个月月初重新开始做历史拉链，目录结构如下：

|-- 201410/ # 每月一个周期
|---- 20141001/ 201410_INFINITY # 历史截止自当前月仍然没有死亡的记录
|---- 20141001/20141002 # 历史截止自当前月到20141002死亡的记录
|---- 20141001/20141003 # 历史截止自当前月到20141003死亡的记录
…
|----- 20141001/20141031 # 历史截止自当前月到20141031死亡的记录
|----- 20141002/ 201410_INFINITY # 20141002新增或历史原有记录发生变更，当前月仍然没有死亡的记录
|---- -20141002/20141003 # 20141002新增或原有记录发生变更，到20141003死亡的记录
…
|---- 20141002 /20141031/ # 20141002新增或原有记录发生变更，到20141031死亡的记录
|-----20141003/ 201410_INFINITY # 20141003新增或历史原有记录发生变更，当前月仍然没有死亡的记录
…
|---- 20141031/ 201410_INFINITY # 20141031新增或历史原有记录发生变更，当前月仍然没有死亡的记录
|-- 201411/
…

  再计算下，一年下来，假设按照每个月30天算，我们产生的分区数：12*(31*30)/2=5580个。

  采用极限存储的处理方式，极大的压缩了全量存储的存储成本，又可以做到对于下游用户透明的效果，是一种比较理想的存储方式。但是其本身也有一定的局限性，首先其产出效率很低，大部分极限存储通常需要t-2；其次对于变化频率高的数据并不能做到节约成本的效果。因此，在实际生产中，做极限存储需要做一些额外的处理：

  （1）极限存储前面有一个全量存储表，全量存储表仅保留最近一段时间的全量分区数据，历史数据通过映射的方式关联到极限存储表。即用户只访问全量存储表，所以对用户来说极限存储是不可见的。

  （2）对于部分变化频率频繁的字段需要在过滤，例如用户表中存在用户积分字段，这种字段的值每天都在发生变化，如果不过滤的话，极限存储就相当于每个分区存储一份全量数据，起不到节约存储成本的效果。

# 6.4 微型维度

  采用极限存储，需要避免维度的过度增长。比如对于商品维表，每天20多亿数据，如果设计商品维度时，将值变化频繁的属性加入到商品维度中，极限情况是每天所有商品数据都发生变化。此时，极限存储没有意义。反之，每天所有商品数据都不发生变化，此时只需要存储一天的数据即可。

  通过将一些属性从维度表中移除，放置到全新的维度表中，可以解决维度的过度增长导致的极限存储效果大打折扣的问题。解决方法其中之一就是上一节提到的垂直拆分，保持主维度的稳定。另外一种方式是采用微型维度。

  微型维度的创建是通过将一部分不稳定的属性从主维度中移出，并将它们放置到拥有自己代理键的新表中来实现的。这些属性相互之间没有直接关联，不存在自然键。通过为每个组合创建新行的一次性过程来加载数据。比如在淘宝用户维度，用户的注册日期、年龄、性别、身份信息等基本不会发生变化，但用户VIP等级、用户信用评价等级会随着用户的行为不断发生变化。其中VIP等级共有8个值，-1~6；用户信用评价等级共有18个值。假设基于VIP等级和用户信用评价等级构建微型维度，则在此微型维度中共有8*18个组合，即144条记录，代理键可能是1~144。

   以淘宝交易事实表为例，其它维度忽略，星型模式可能表示如下：

![dim_3_4-1](http://aligitlab.oss-cn-hangzhou-zmf.aliyuncs.com/uploads/yongwei.wangyw/model/7eb9677b766432f89229278844edd6b9/dim_3_4-1.png)

  但在阿里巴巴数据仓库实践中，并未使用此技术，主要有以下几点原因：

  （1）微型维度的局限性。微型维度是事先用所有可能值的组合加载的，需要考虑每个属性的基数，且必须是枚举值。很多属性可能是非枚举型，比如数值类型，如VIP分数、信用分数；比如时间类型，上架时间、下架时间、变更时间等等。

  （2）ETL逻辑复杂。对于分布式系统中生成代理键和使用代理键进行ETL加工都非常复杂，前面章节已经有介绍，ETL开发和维护成本过高。

  （3）破坏了维度的可浏览性。买家维度和微型维度通过事实表建立联系，无法基于VIP等级和信用等级进行浏览和统计。可以通过在买家维度中添加引用微型维度的外键部分解决此问题，但带来的问题是微型维度未维护历史信息。